@Enumeration(DecodeMode [None Hadamard])
@Enumeration(RCAOrientation [None Rows Columns])
@Enumeration(SamplingMode [2X 4X])

@Table([name size elements]) DataKind
{
	[Int16          2 1]
	[Int16Complex   2 2]
	[Float32        4 1]
	[Float32Complex 4 2]
}

@Enumeration(EmissionKind [Sine SineAM Chirp])

@Table([c_type m_type name]) SineParameters
{
	[f32 single cycles   ]
	[f32 single frequency]
}

@Table([c_type m_type name]) SineAMParameters
{
	[f32 single cycles   ]
	[f32 single frequency]
	[u32 uint32 emissions]
}

@Table([c_type m_type name]) ChirpParameters
{
	[f32 single duration     ]
	[f32 single min_frequency]
	[f32 single max_frequency]
}

@MUnion(EmissionKind [
	SineParameters
	SineAMParameters
	ChirpParameters
]) Emission

@Table([name name_lower]) FilterKind
{
	[Kaiser       kaiser]
	[MatchedChirp matched_chirp]
}

@Table([c_type m_type name]) KaiserFilterParameters
{
	[f32 single cutoff_frequency]
	[f32 single beta]
	[u32 uint32 length]
}

@Table([c_type m_type name]) ChirpFilterParameters
{
	[f32 single duration]
	[f32 single min_frequency]
	[f32 single max_frequency]
}

@MUnion(FilterKind [
	KaiserFilterParameters
	ChirpFilterParameters
]) Filter

@Table([name pretty_name fixed_transmits]) AcquisitionKind
{
	[FORCES         FORCES         1]
	[UFORCES        UFORCES        0]
	[HERCULES       HERCULES       1]
	[RCA_VLS        VLS            0]
	[RCA_TPW        TPW            0]
	[UHERCULES      UHERCULES      0]
	[RACES          RACES          1]
	[EPIC_FORCES    EPIC-FORCES    1]
	[EPIC_UFORCES   EPIC-UFORCES   0]
	[EPIC_UHERCULES EPIC-UHERCULES 0]
	[Flash          Flash          0]
	[HERO_PA        HERO-PA        0]
}

@Table([name]) InterpolationMode
{
	[Nearest]
	[Linear]
	[Cubic]
}

@Expand(AcquisitionKind)   @Enumeration(AcquisitionKind   `$(name)`)
@Expand(DataKind)          @Enumeration(DataKind          `$(name)`)
@Expand(FilterKind)        @Enumeration(FilterKind        `$(name)`)
@Expand(InterpolationMode) @Enumeration(InterpolationMode `$(name)`)

@Emit
{
	`typedef struct {`
	`	BeamformerEmissionKind kind;`
	`	union {`
	`		struct {`
			@Expand(SineParameters)   `			$(c_type)$(|)$(name);`
	`		} sine;`
	`		struct {`
			@Expand(SineAMParameters) `			$(c_type)$(|)$(name);`
	`		} sine_am;`
	`		struct {`
			@Expand(ChirpParameters)  `			$(c_type)$(|)$(name);`
	`		} chirp;`
	`	};`
	`} BeamformerEmission;`
	``
	`typedef struct {`
	`	BeamformerFilterKind kind;`
	`	union {`
	`		struct {`
			@Expand(KaiserFilterParameters) `			$(c_type)$(|)$(name);`
	`		} kaiser;`
	`		struct {`
			@Expand(ChirpFilterParameters)  `			$(c_type)$(|)$(name);`
	`		} matched_chirp;`
	`	};`
	`	f32 sampling_frequency;`
	`	b16 complex;`
	`} BeamformerFilterParameters;`
	``
	`read_only global u8 beamformer_data_kind_element_size[] = {`
	@Expand(DataKind) `	$(size),`
	`};`
	``
	`read_only global u8 beamformer_data_kind_element_count[] = {`
	@Expand(DataKind) `	$(elements),`
	`};`
	``
	`read_only global u8 beamformer_data_kind_byte_size[] = {`
	@Expand(DataKind) `	$(size) * $(elements),`
	`};`
	``
	`read_only global u8 beamformer_acquisition_kind_has_fixed_transmits[] = {`
	@Expand(AcquisitionKind) `	$(fixed_transmits),`
	`};`
	``
	`read_only global s8 beamformer_acquisition_kind_strings[] = {`
	@Expand(AcquisitionKind) `	s8_comp("$(pretty_name)"),`
	`};`
	``
	`read_only global s8 beamformer_filter_kind_strings[] = {`
	@Expand(FilterKind) `	s8_comp("$(name)"),`
	`};`
	``
	`read_only global s8 beamformer_interpolation_mode_strings[] = {`
	@Expand(InterpolationMode) `	s8_comp("$(name)"),`
	`};`
}

@ShaderGroup Compute
{
	@Shader CudaDecode
	@Shader CudaHilbert

	@Shader(decode.glsl) Decode
	{
		@Enumeration(DataKind)
		@Enumeration(DecodeMode)
		@Flags([DilateOutput UseSharedMemory])

		@Bake
		{
			@BakeInt(DecodeMode           decode_mode           )
			@BakeInt(InputChannelStride   input_channel_stride  )
			@BakeInt(InputSampleStride    input_sample_stride   )
			@BakeInt(InputTransmitStride  input_transmit_stride )
			@BakeInt(OutputChannelStride  output_channel_stride )
			@BakeInt(OutputSampleStride   output_sample_stride  )
			@BakeInt(OutputTransmitStride output_transmit_stride)
			@BakeInt(ToProcess            to_process            )
			@BakeInt(TransmitCount        transmit_count        )
		}
	}

	@Shader(filter.glsl) Filter
	{
		@Enumeration(DataKind)
		@Flags([ComplexFilter OutputFloats])

		@Bake
		{
			@BakeInt(DecimationRate       decimation_rate       )
			@BakeInt(FilterLength         filter_length         )
			@BakeInt(InputChannelStride   input_channel_stride  )
			@BakeInt(InputSampleStride    input_sample_stride   )
			@BakeInt(InputTransmitStride  input_transmit_stride )
			@BakeInt(OutputChannelStride  output_channel_stride )
			@BakeInt(OutputSampleStride   output_sample_stride  )
			@BakeInt(OutputTransmitStride output_transmit_stride)
			@BakeInt(SampleCount          sample_count          )
			@BakeFloat(DemodulationFrequency demodulation_frequency)
			@BakeFloat(SamplingFrequency     sampling_frequency    )
		}

		@SubShader Demodulate
	}

	@Shader(das.glsl) DAS
	{
		@Enumeration(AcquisitionKind)
		@Enumeration(DataKind)
		@Enumeration(InterpolationMode)
		@Enumeration(RCAOrientation)
		@Flags([Fast Sparse CoherencyWeighting SingleFocus SingleOrientation])

		@Bake
		{
			@BakeInt(AcquisitionCount           acquisition_count           )
			@BakeInt(AcquisitionKind            acquisition_kind            )
			@BakeInt(ChannelCount               channel_count               )
			@BakeInt(InterpolationMode          interpolation_mode          )
			@BakeInt(SampleCount                sample_count                )
			@BakeInt(TransmitReceiveOrientation transmit_receive_orientation)

			@BakeFloat(DemodulationFrequency demodulation_frequency)
			@BakeFloat(FNumber               f_number              )
			@BakeFloat(FocusDepth            focus_depth           )
			@BakeFloat(SamplingFrequency     sampling_frequency    )
			@BakeFloat(SpeedOfSound          speed_of_sound        )
			@BakeFloat(TimeOffset            time_offset           )
			@BakeFloat(TransmitAngle         transmit_angle        )
		}
	}

	@Shader(min_max.glsl) MinMax
	@Shader(sum.glsl) Sum
}

@ShaderGroup Render
{
	@Shader(render_3d.frag.glsl) Render3D
}
